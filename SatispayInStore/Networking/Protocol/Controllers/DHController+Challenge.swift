//
//  DHController+Challenge.swift
//  SatispayInStore
//
//  Created by Pierluigi D'Andrea on 09/10/17.
//  Copyright Â© 2017 Satispay. All rights reserved.
//

import Foundation

public extension DHController {

    /// The client encrypt a locally generated secret string using a well-known server public key
    /// and challenges the server to properly decrypt it. If the server returns the correct string the endpoint is validated.
    ///
    /// - Parameters:
    ///   - params: DH parameters generated by `generateParameters`.
    ///   - exchangeResponse: Response of `exchange(parameters:completionHandler:)`.
    public func challenge(parameters params: DHParams,
                          exchangeResponse: DHExchangeResponse,
                          completionHandler: @escaping CompletionHandler<(Context, DHChallengeResponse)>) -> CancellableOperation? {

        do {

            guard let request = try? DHChallengeRequest() else {
                throw DHError.cannotEncryptUUID
            }

            guard let kMaster = params.sharedSecret(exchangeResponse.publicKey) else {
                throw DHError.cannotComputeSharedSecret
            }

            let context = Context(keyId: exchangeResponse.keyId, kMaster: kMaster)

            guard let kAuth = context.kAuth, let kSess = context.kSess else {
                throw DHError.cannotComputeSharedSecret
            }

            let encryptedRequest = try DHEncryptedRequest(keyId: context.keyId,
                                                          kAuth: kAuth,
                                                          kSess: kSess,
                                                          payload: request)

            return DHService.challenge(request: encryptedRequest).request(mapping: { (data) -> DHChallengeResponse in

                let encrypted: DHEncryptedResponse = try NetworkController.attemptDecode(of: data)
                let data = try encrypted.decrypt(kSess: kSess, kAuth: kAuth)
                let response: DHChallengeResponse = try NetworkController.attemptDecode(of: data)

                guard response.challenge == request.uuid else {
                    throw DHError.challengeResponseVerificationFailure
                }

                return try NetworkController.attemptDecode(of: data)

            }, completionHandler: { (response: DHChallengeResponse?, _, error: Error?) in

                guard let response = response else {
                    return completionHandler(nil, .any(DHError.challengeResponseFailure))
                }

                completionHandler((context, response), .any(error))

            })

        } catch let error {

            completionHandler(nil, .any(error))
            return nil

        }

    }

}
